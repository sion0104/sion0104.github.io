---

title: "[iOS/HTTP] 로그인은 성공했는데 사용자 조회에서 500이 발생한 케이스 정리"
date: 2025-12-15
categories:
    - iOS
    - Network
    - HTTP
    - Swift
tags: [iOS, Swift, HTTP, 500, InternalServerError, 네트워크, 인증]

---

# 로그인은 성공했는데 사용자 조회에서 500이 발생한 케이스 정리

API 연동 중 **500 Internal Server Error**를 마주하면 보통
“서버가 잘못됐겠지”라고 생각하기 쉽다.

하지만 이번에 겪은 오류는 조금 특이했다.

> **로그인 API는 200으로 정상 성공했지만,
> 바로 다음 사용자 조회 API에서 500이 발생한 케이스**

이 글에서는 이 **비정상적인 흐름**이 왜 발생했는지,
그리고 클라이언트 코드 관점에서 어떻게 해결했는지를 정리한다.

---

## 1. 문제 상황 요약

실제 요청 흐름은 다음과 같았다.

```text
POST /v1/auth/sign-in  → 200 OK (토큰 발급 성공)
GET  /v1/user          → 500 Internal Server Error
```

로그인 자체는 성공했고, 서버로부터 `accessToken`과 `refreshToken`도 정상적으로 내려왔다.
그럼에도 불구하고, **로그인 직후 사용자 정보를 조회하는 단계에서 서버 오류가 발생**했다.

---

## 2. 왜 이 흐름이 이상한가

일반적인 인증 흐름은 다음과 같다.

1. 로그인 성공
2. 토큰 발급
3. 토큰을 이용해 사용자 정보 조회
4. 사용자 데이터 반환 (200)

하지만 이번 경우에는 **2번까지는 정상**,
**3번 단계에서 서버 내부 오류(500)** 가 발생했다.

이런 케이스는 보통:

* 서버 인증 처리
* 보안 필터
* 토큰 파싱 로직
  중 하나에서 **전제 조건이 깨졌을 때** 발생한다.

---

## 3. 이론적 원인 분석

### (1) /v1/user는 인증이 필요한 API

`GET /v1/user`는 로그인된 사용자만 접근할 수 있는 API다.
서버는 다음 헤더가 포함된 요청을 기대한다.

```http
Authorization: Bearer {accessToken}
```

---

### (2) 실제 요청에는 Authorization 헤더가 없었다

초기 iOS 구현에서는:

* 로그인 성공 후 토큰을 저장만 하고
* 이후 API 요청에 토큰을 포함하지 않았다

```http
GET /v1/user
(Authorization 헤더 없음)
```

---

### (3) 서버 내부에서 발생한 실제 흐름 (추정)

```text
1. Authorization 헤더 파싱 시도
2. accessToken 없음
3. 인증 객체(SecurityContext) 생성 실패
4. 이후 비즈니스 로직에서 null 참조
5. 예외 발생
6. 500 Internal Server Error 반환
```

정상적인 설계라면 이 경우 **401 Unauthorized**가 맞지만,
인증 필터 또는 예외 처리 미흡으로 인해
500으로 전파되는 경우도 실무에서 종종 발생한다.

---

## 4. 이번 500 오류의 핵심 포인트

이번 오류의 핵심은 단순하다.

> **로그인은 성공했지만,
> 로그인 이후 단계에서 필요한 인증 정보가 누락된 상태로
> API를 호출했다는 점**

즉, **로그인 성공 ≠ 인증 완료 상태**라는 점을 간과한 것이다.

---

## 5. 해결 방법

### ✔ 핵심 해결 전략

> **로그인 이후 호출되는 모든 인증 API 요청에
> Authorization 헤더를 자동으로 포함한다**

---

### ✔ 적용한 코드

토큰을 전역으로 관리하고,
`APIClient` 레벨에서 모든 요청에 Authorization 헤더를 자동 주입하도록 수정했다.

```swift
if let auth = TokenStore.shared.loadAuthorizationValue() {
    request.setValue(auth, forHTTPHeaderField: "Authorization")
}
```

이 코드를 `get`, `post`, `delete` 등
**URLRequest 생성 직후 공통으로 적용**했다.

---

## 6. 해결 후 결과

```text
POST /v1/auth/sign-in → 200
GET  /v1/user         → 200
```

로그인 → 사용자 조회 흐름이 정상적으로 이어졌고,
500 오류는 더 이상 발생하지 않았다.

---

## 7. 이 케이스에서 얻은 교훈

이번 경험을 통해 얻은 가장 중요한 교훈은 다음과 같다.

* 로그인 성공만으로 인증이 끝난 것이 아니다
* 인증이 필요한 API는 **항상 토큰 전달을 전제로 한다**
* 500 오류라도 클라이언트 원인일 수 있다
* 인증/보안 로직은 공통 레이어에서 처리해야 한다

---

## 8. 정리

이번 500 오류는 서버가 무작정 실패한 것이 아니라,
**클라이언트 요청이 서버 내부 전제 조건을 깨뜨린 결과**였다.

> **“200 다음에 500이 나오는 흐름”은
> 인증 헤더 누락을 가장 먼저 의심해야 한다.**

특히 로그인 직후 이어지는 API 호출에서는
Authorization 헤더 포함 여부가 가장 중요한 체크 포인트다.
